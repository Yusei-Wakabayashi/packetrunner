<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Packet Runner - 縦向きプロトタイプ</title>
<style>
  :root{
    --bg:#020617;
    --ground:#111827;
    --player:#60a5fa;
    --obstacle:#ef4444;
    --hud:#e5e7eb;
  }
  html,body{
    margin:0;
    padding:0;
    height:100%;
    background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;
    color:var(--hud);
  }
  body{
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .app{
    width:100%;
    max-width:480px;
    height:100%;
    max-height:900px;
    display:flex;
    flex-direction:column;
    padding:8px;
    box-sizing:border-box;
    gap:8px;
  }
  .header{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .title{
    font-size:18px;
    font-weight:700;
  }
  .subtitle{
    font-size:13px;
    color:#94a3b8;
  }
  .mode-toggle{
    display:flex;
    gap:8px;
    margin-top:4px;
    font-size:13px;
    flex-wrap:wrap;
  }
  canvas{
    flex:1;
    background:radial-gradient(circle at 50% 0%,#1f2937,#020617);
    border-radius:12px;
    touch-action:none;
  }
  .hud-bar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:13px;
  }
  .hud-group{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  button{
    background:#111827;
    border:1px solid #374151;
    color:var(--hud);
    border-radius:999px;
    padding:6px 12px;
    font-size:13px;
    cursor:pointer;
  }
  button.big{
    font-weight:600;
    padding:8px 16px;
  }
  .footer{
    font-size:11px;
    color:#64748b;
    text-align:center;
  }

  /* オーバーレイ（GameOver/Goal） */
  .overlay{
    position:absolute;
    inset:0;
    display:none;
    justify-content:center;
    align-items:center;
    pointer-events:none;
  }
  .overlay.visible{
    display:flex;
    pointer-events:auto;
  }
  .overlay-inner{
    background:rgba(15,23,42,0.9);
    border-radius:16px;
    padding:20px;
    width:80%;
    max-width:320px;
    text-align:center;
    box-shadow:0 20px 30px rgba(0,0,0,0.5);
    border:1px solid rgba(148,163,184,0.4);
  }
  .overlay-title{
    font-size:24px;
    font-weight:800;
    margin-bottom:8px;
  }
  .overlay-msg{
    font-size:13px;
    color:#cbd5f5;
    margin-bottom:16px;
    white-space:pre-line;
  }
  .overlay-buttons{
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .overlay-buttons button{
    width:100%;
  }
  .mode-pill{
    padding:2px 8px;
    border-radius:999px;
    border:1px solid #4b5563;
    font-size:11px;
  }

  .game-container{
    position:relative;
    flex:1;
    display:flex;
  }

  @media (orientation:landscape){
    .subtitle::after{
      content:"（スマホ縦向き推奨）";
      margin-left:4px;
      color:#f97316;
    }
  }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">Packet Runner</div>
    <div class="subtitle">タップ（クリック / Space / ↑）でジャンプして障害を回避しよう。</div>
    <div class="mode-toggle">
      <span class="mode-pill">Mode: <span id="modeLabel">TA</span></span>
      <label><input type="radio" name="mode" value="ta" checked> TA（タイムアタック）</label>
      <label><input type="radio" name="mode" value="life"> Life（ライフ制）</label>
    </div>
  </div>

  <div class="game-container">
    <canvas id="game"></canvas>
    <div id="overlay" class="overlay">
      <div class="overlay-inner">
        <div id="overlayTitle" class="overlay-title">GAME OVER</div>
        <div id="overlayMsg" class="overlay-msg"></div>
        <div class="overlay-buttons">
          <button id="retryBtn" class="big">もう一度プレイ</button>
          <button id="backTitleBtn">タイトルに戻る</button>
        </div>
      </div>
    </div>
  </div>

  <div class="hud-bar">
    <div class="hud-group">
      <span id="timeLabel">Time: 0.00s</span>
      <span id="livesLabel" style="display:none">Lives: 3</span>
      <span id="bestLabel">Best: —</span>
    </div>
    <div class="hud-group">
      <button id="startBtn" class="big">START</button>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <div class="footer">
    ※画像は後で差し替え可能。今はプレイヤー・障害物とも色ブロックのみ。
  </div>
</div>

<script>
/* ===== 基本設定（縦画面用） ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function initCanvasSize(){
  // app の高さに合わせて、キャンバスはほぼ正方形〜縦長にする
  const rect = canvas.parentElement.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height);
  canvas.style.width = rect.width + "px";
  canvas.style.height = rect.height + "px"; // 縦いっぱい
  resizeCanvas();
}
window.addEventListener('resize', initCanvasSize);
initCanvasSize();

/* ===== UI参照 ===== */
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const retryBtn = document.getElementById('retryBtn');
const backTitleBtn = document.getElementById('backTitleBtn');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayMsg = document.getElementById('overlayMsg');

const modeLabel = document.getElementById('modeLabel');
const timeLabel = document.getElementById('timeLabel');
const livesLabel = document.getElementById('livesLabel');
const bestLabel = document.getElementById('bestLabel');

let mode = 'ta';
document.querySelectorAll('input[name="mode"]').forEach(r=>{
  r.addEventListener('change', e=>{
    mode = e.target.value;
    modeLabel.textContent = mode === 'ta' ? 'TA' : 'Life';
    updateHudVisibility();
  });
});

function updateHudVisibility(){
  if(mode === 'ta'){
    livesLabel.style.display = 'none';
    bestLabel.style.display = '';
  }else{
    livesLabel.style.display = '';
    bestLabel.style.display = 'none';
  }
}
updateHudVisibility();

/* ===== ゲームロジック（縦用に調整） ===== */
const GAME = {
  width: 360, // 仮想幅
  height: 640, // 仮想高さ（縦長）
  groundY: 520,
  gravity: 1300,
  jumpImpulse: -480,
  scrollSpeed: 240,
  playerX: 80
};

const player = {
  x: GAME.playerX,
  y: 0,
  w: 36,
  h: 36,
  vy: 0,
  onGround: false,
  color: getComputedStyle(document.documentElement).getPropertyValue('--player').trim()
};

let running = false;
let inTitle = true;
let lastTime = 0;
let elapsed = 0;
let elapsedSinceStart = 0;
let mapOffset = 0;
let mapData = null;
let lives = 3;

let bestTimeKey = 'packet-runner-best-time-vertical';
let taBest = localStorage.getItem(bestTimeKey) ? parseFloat(localStorage.getItem(bestTimeKey)) : null;
bestLabel.textContent = taBest ? 'Best: ' + taBest.toFixed(2) + 's' : 'Best: —';

function generateMap(totalLength = 2800){
  const segs = [];
  let x = 0;
  const minRun = 140;
  while(x < totalLength){
    const r = Math.random();
    if(r < 0.2 && x > 200){
      const gapW = randInt(70, 200);
      segs.push({type:'gap', x, width:gapW});
      x += gapW;
      const run = randInt(100, 180);
      segs.push({type:'ground', x, width:run});
      x += run;
    } else {
      const run = randInt(minRun, minRun+220);
      segs.push({type:'ground', x, width:run});
      if(Math.random() < 0.3 && x > 180){
        const blockW = randInt(26,50);
        const blockH = randInt(30,80);
        segs.push({type:'block', x:x+randInt(40,Math.max(60,run-20)), width:blockW, height:blockH});
      }
      x += run;
    }
  }
  segs.push({type:'goal', x: totalLength+40, width: 40});
  return {totalLength, segments:segs};
}
function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function resetGame(){
  running = false;
  lastTime = 0;
  elapsed = 0;
  elapsedSinceStart = 0;
  mapOffset = 0;
  player.y = GAME.groundY - player.h;
  player.vy = 0;
  player.onGround = true;
  lives = 3;
  timeLabel.textContent = 'Time: 0.00s';
  livesLabel.textContent = 'Lives: ' + lives;
  mapData = generateMap(3200 + Math.floor(Math.random()*1200));
  hideOverlay();
}

function startGame(){
  inTitle = false;
  resetGame();
  running = true;
  lastTime = performance.now();
  taBest = localStorage.getItem(bestTimeKey) ? parseFloat(localStorage.getItem(bestTimeKey)) : null;
  bestLabel.textContent = taBest ? 'Best: ' + taBest.toFixed(2) + 's' : 'Best: —';
  requestAnimationFrame(loop);
}

function backToTitle(){
  running = false;
  inTitle = true;
  resetGame();
}

startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', ()=>{
  resetGame();
  startGame();
});
retryBtn.addEventListener('click', ()=>{
  startGame();
});
backTitleBtn.addEventListener('click', ()=>{
  backToTitle();
});

/* ジャンプ入力 */
function doJump(){
  if(!running) return;
  if(player.onGround){
    player.vy = GAME.jumpImpulse;
    player.onGround = false;
  }
}
window.addEventListener('keydown', e=>{
  if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); doJump(); }
  if(e.key === 'r'){ resetGame(); startGame(); }
});
canvas.addEventListener('mousedown', ()=>{ doJump(); });
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); doJump(); }, {passive:false});

/* メインループ */
let invulnerableTimer = 0;
let flashT = 0;

function loop(ts){
  if(!running) { render(); return; }
  const dt = Math.min(0.05, (ts - lastTime)/1000);
  lastTime = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

function update(dt){
  elapsed += dt;
  elapsedSinceStart += dt;

  // 重力・移動
  player.vy += GAME.gravity * dt;
  player.y += player.vy * dt;

  const worldX = mapOffset + player.x + player.w/2;
  const onGroundNow = isGroundAt(worldX);

  if(onGroundNow){
    if(player.y + player.h >= GAME.groundY){
      player.y = GAME.groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    }
  }else{
    player.onGround = false;
  }

  mapOffset += GAME.scrollSpeed * dt;

  timeLabel.textContent = 'Time: ' + elapsedSinceStart.toFixed(2) + 's';
  livesLabel.textContent = 'Lives: ' + lives;

  const blocks = mapData.segments.filter(s=>s.type==='block');
  for(const b of blocks){
    const bx = b.x - mapOffset;
    const by = GAME.groundY - b.height;
    if(rectsOverlap(player.x, player.y, player.w, player.h, bx, by, b.width, b.height)){
      handleHit();
      break;
    }
  }

  const canvasHeight = canvas.clientHeight;
  if(player.y > canvasHeight + 40){
    handleHit(true);
  }

  const goalSeg = mapData.segments.find(s=>s.type==='goal');
  if(goalSeg){
    const gx = goalSeg.x - mapOffset;
    if(gx + goalSeg.width < player.x + player.w){
      handleVictory();
    }
  }

  if(invulnerableTimer > 0) invulnerableTimer = Math.max(0, invulnerableTimer - dt);
  if(flashT > 0) flashT = Math.max(0, flashT - dt);
}

function isGroundAt(worldX){
  for(const s of mapData.segments){
    if(s.type === 'gap'){
      if(worldX >= s.x && worldX < s.x + s.width) return false;
    }
  }
  return true;
}

function handleHit(){
  if(invulnerableTimer > 0) return;
  invulnerableTimer = 0.8;
  flashT = 0.2;

  if(mode === 'ta'){
    running = false;
    showOverlay("GAME OVER","障害にぶつかってしまった…\nTAは失敗です。\nもう一度挑戦しますか？");
  }else{
    lives -= 1;
    livesLabel.textContent = 'Lives: ' + lives;
    if(lives <= 0){
      running = false;
      showOverlay("GAME OVER","ライフがなくなってしまった…\nもう一度挑戦しますか？");
    }else{
      player.y = GAME.groundY - player.h;
      player.vy = 0;
      player.onGround = true;
      mapOffset = Math.max(0, mapOffset - 180);
    }
  }
}

function handleVictory(){
  running = false;
  if(mode === 'ta'){
    const t = elapsedSinceStart;
    const prev = localStorage.getItem(bestTimeKey) ? parseFloat(localStorage.getItem(bestTimeKey)) : null;
    let msg;
    if(prev === null || t < prev){
      localStorage.setItem(bestTimeKey, String(t));
      taBest = t;
      bestLabel.textContent = 'Best: ' + taBest.toFixed(2) + 's';
      msg = `GOAL！\nNew Best: ${t.toFixed(2)}s`;
    }else{
      msg = `GOAL！\nTime: ${t.toFixed(2)}s`;
    }
    showOverlay("GOAL", msg + "\nもう一度挑戦しますか？");
  }else{
    showOverlay("GOAL","ゴールに到達しました！\nもう一度挑戦しますか？");
  }
}

/* オーバーレイ表示 */
function showOverlay(title, msg){
  overlayTitle.textContent = title;
  overlayMsg.textContent = msg;
  overlay.classList.add('visible');
}
function hideOverlay(){
  overlay.classList.remove('visible');
}

/* 描画 */
function render(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  // 背景
  ctx.fillStyle = "#020617";
  ctx.fillRect(0,0,w,h);

  // 地面
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground').trim();
  ctx.fillRect(0,GAME.groundY,w,h-GAME.groundY);

  // セグメント描画
  for(const s of mapData.segments){
    const x = s.x - mapOffset;
    if(x + s.width < -100 || x > w+100) continue;
    if(s.type === 'gap'){
      ctx.fillStyle = "#020617";
      ctx.fillRect(x,GAME.groundY,s.width, h-GAME.groundY);
    }else if(s.type === 'block'){
      const by = GAME.groundY - s.height;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--obstacle').trim();
      ctx.fillRect(x,by,s.width,s.height);
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(x,by,s.width,s.height*0.2);
    }else if(s.type === 'goal'){
      const gx = x;
      const gy = GAME.groundY - 100;
      ctx.fillStyle = "#facc15";
      ctx.fillRect(gx+8,gy,6,90);
      ctx.fillStyle = "#e11d48";
      ctx.beginPath();
      ctx.moveTo(gx+14,gy+12);
      ctx.lineTo(gx+42,gy+32);
      ctx.lineTo(gx+14,gy+50);
      ctx.closePath();
      ctx.fill();
    }
  }

  // プレイヤー
  ctx.save();
  if(invulnerableTimer > 0){
    if(Math.floor(performance.now()/80)%2===0) ctx.globalAlpha = 0.4;
  }
  ctx.fillStyle = player.color || "#60a5fa";
  roundRect(ctx, player.x, player.y, player.w, player.h, 8, true, false);
  ctx.restore();

  // 画面内 HUD（簡易）
  ctx.fillStyle = "#e5e7eb";
  ctx.font = "13px system-ui";
  ctx.fillText("Time: " + elapsedSinceStart.toFixed(2) + "s", 8, 18);
  if(mode === 'life'){
    ctx.fillText("Lives: " + lives, 8, 36);
  }else if(taBest){
    ctx.fillText("Best: " + taBest.toFixed(2) + "s", 8, 36);
  }

  if(flashT > 0){
    ctx.fillStyle = `rgba(248,113,113,${flashT*2})`;
    ctx.fillRect(0,0,w,h);
  }
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if(typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* 初期化 */
mapData = generateMap(3200);
player.y = GAME.groundY - player.h;
player.onGround = true;
render();

console.log("Packet Runner vertical prototype loaded.");
</script>
</body>
</html>
