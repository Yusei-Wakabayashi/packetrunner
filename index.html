<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Packet Runner - Fixed</title>
<style>
  :root{
    --bg:#020617;        /* 画面外背景（ボディ） */
    --ground:#064e3b;    /* 地面のベースカラー（濃いグリーン） */
    --ground-top:#22c55e;/* 地面の上端ライン */
    --player:#e0f2fe;    /* プレイヤーは少し明るくして見やすく */
    --obstacle:#f97373;  /* 障害物も少し柔らかい赤に */
    --hud:#e5e7eb;
  }

  html,body{
    margin:0;
    padding:0;
    height:100%;
    background:#020617; /* キャンバス外側は真っ暗 */
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;
    color:var(--hud);
  }

  body{
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .app{
    width:100%;
    max-width:480px;
    height:100%;
    max-height:900px;
    display:flex;
    flex-direction:column;
    padding:8px;
    box-sizing:border-box;
    gap:8px;
  }
  .header{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .title{
    font-size:18px;
    font-weight:700;
  }
  .subtitle{
    font-size:13px;
    color:#94a3b8;
  }
  .game-container{
    position:relative;
    flex:1;
    display:flex;
  }
  canvas{
    flex:1;
    /* === 背景：データセンター風グラデーション＋縦ライン === */
    background:
      /* 縦ラインのグリッド（うっすら） */
      linear-gradient(90deg,
        rgba(148,163,184,0.15) 1px,
        transparent 1px
      ),
      /* 斜めの光筋 */
      linear-gradient(135deg,
        rgba(56,189,248,0.25),
        transparent 55%
      ),
      /* 下側の光り方 */
      radial-gradient(circle at 50% 100%,
        rgba(34,211,238,0.4),
        transparent 60%
      ),
      /* 全体の縦グラデーション */
      linear-gradient(to bottom,
        #020617 0%,
        #0f172a 40%,
        #020617 75%,
        #020617 100%
      );
    background-size:
      40px 100%,   /* 縦ラインの間隔 */
      100% 100%,
      100% 100%,
      100% 100%;
    border-radius:12px;
    touch-action:none;
  }
  .hud-bar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:13px;
  }
  .hud-group{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  button{
    background:#111827;
    border:1px solid #374151;
    color:var(--hud);
    border-radius:999px;
    padding:6px 12px;
    font-size:13px;
    cursor:pointer;
  }
  button.big{
    font-weight:600;
    padding:8px 16px;
  }
  .footer{
    font-size:11px;
    color:#64748b;
    text-align:center;
  }

  /* タイトル＆ゲームオーバーオーバーレイ */
  .title-overlay,
  .overlay{
    position:absolute;
    inset:0;
    display:flex;
    justify-content:center;
    align-items:center;
    pointer-events:none;
  }
  .title-overlay.visible,
  .overlay.visible{
    pointer-events:auto;
  }
  .title-card,
  .overlay-inner{
    background:rgba(15,23,42,0.96);
    border-radius:18px;
    padding:20px;
    width:86%;
    max-width:360px;
    box-shadow:0 20px 30px rgba(0,0,0,0.5);
    border:1px solid rgba(148,163,184,0.5);
  }
  .title-overlay{
    display:none;
  }
  .title-overlay.visible{
    display:flex;
  }
  .game-title{
    font-size:24px;
    font-weight:800;
    margin-bottom:4px;
  }
  .game-caption{
    font-size:12px;
    color:#cbd5f5;
    margin-bottom:12px;
  }
  .select-group{
    margin-bottom:12px;
  }
  .select-label{
    font-size:12px;
    color:#9ca3af;
    margin-bottom:4px;
  }
  .select-row{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .pill{
    border-radius:999px;
    border:1px solid #4b5563;
    padding:4px 10px;
    font-size:12px;
    cursor:pointer;
    display:flex;
    align-items:center;
    gap:4px;
  }
  .pill input{
    accent-color:#60a5fa;
  }
  .title-buttons{
    display:flex;
    flex-direction:column;
    gap:8px;
    margin-top:8px;
  }
  .title-note{
    font-size:11px;
    color:#64748b;
    margin-top:6px;
  }
  .overlay{
    display:none;
  }
  .overlay.visible{
    display:flex;
  }
  .overlay-title{
    font-size:24px;
    font-weight:800;
    margin-bottom:8px;
    text-align:center;
  }
  .overlay-msg{
    font-size:13px;
    color:#cbd5f5;
    margin-bottom:16px;
    white-space:pre-line;
    text-align:center;
  }
  .overlay-buttons{
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .overlay-buttons button{
    width:100%;
  }
  .mode-chip,
  .difficulty-chip{
    padding:2px 8px;
    border-radius:999px;
    border:1px solid #4b5563;
    font-size:11px;
  }
  @media (orientation:landscape){
    .subtitle::after{
      content:"（スマホ縦向き推奨）";
      margin-left:4px;
      color:#f97316;
    }
  }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">Packet Runner</div>
    <div class="subtitle">タップ（クリック / Space / ↑）でジャンプして障害を回避しよう。</div>
  </div>

  <div class="game-container">
    <canvas id="game"></canvas>

    <!-- タイトル -->
    <div id="titleOverlay" class="title-overlay visible">
      <div class="title-card">
        <div class="game-title">Packet Runner</div>
        <div class="game-caption">
          パケットがネットワークの障害を乗り越えながらゴールを目指すランゲーム。
        </div>

        <div class="select-group">
          <div class="select-label">ゲームモード</div>
          <div class="select-row">
            <label class="pill">
              <input type="radio" name="mode" value="ta" checked>
              <span>TA（タイムアタック）</span>
            </label>
            <label class="pill">
              <input type="radio" name="mode" value="life">
              <span>Life（ライフ制）</span>
            </label>
          </div>
        </div>

        <div class="select-group">
          <div class="select-label">難易度</div>
          <div class="select-row">
            <label class="pill">
              <input type="radio" name="difficulty" value="normal" checked>
              <span>Normal</span>
            </label>
            <label class="pill">
              <input type="radio" name="difficulty" value="hard">
              <span>Hard</span>
            </label>
            <label class="pill">
              <input type="radio" name="difficulty" value="veryhard">
              <span>Very Hard</span>
            </label>
          </div>
        </div>

        <div class="title-buttons">
          <button id="titleStartBtn" class="big">START</button>
        </div>
        <div class="title-note">
          ・TA: ゴールまでのタイムを記録<br>
          ・Life: ライフが0になる前にゴールを目指そう<br>
          ・難易度で障害物の高さ・数が変化します。
        </div>
      </div>
    </div>

    <!-- GameOver / Goal -->
    <div id="overlay" class="overlay">
      <div class="overlay-inner">
        <div id="overlayTitle" class="overlay-title">GAME OVER</div>
        <div id="overlayMsg" class="overlay-msg"></div>
        <div class="overlay-buttons">
          <button id="retryBtn" class="big">もう一度プレイ</button>
          <button id="backTitleBtn">タイトルに戻る</button>
        </div>
      </div>
    </div>
  </div>

  <div class="hud-bar">
    <div class="hud-group">
      <span class="mode-chip">Mode: <span id="modeLabel">TA</span></span>
      <span class="difficulty-chip">Difficulty: <span id="difficultyLabel">Normal</span></span>
    </div>
    <div class="hud-group">
      <span id="timeLabel">Time: 0.00s</span>
      <span id="livesLabel" style="display:none">Lives: 3</span>
      <span id="bestLabel">Best: —</span>
    </div>
  </div>

  <div class="footer">
    ※画像は後で差し替え可能。今はプレイヤー・障害物とも色ブロックのみです。
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
/* ゲーム定数 */
const GAME = {
  width: 360,
  height: 640,
  groundRatio: 0.8,
  groundY: 520,
  gravity: 1300,
  jumpImpulse: -480,
  scrollSpeed: 240,
  playerX: 80
};
const player = {
  x: GAME.playerX,
  y: 0,
  w: 36,
  h: 36,
  vy: 0,
  onGround: false,
  color: getComputedStyle(document.documentElement).getPropertyValue('--player').trim()
};
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function initCanvasSize(){
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.style.width  = rect.width + "px";
  canvas.style.height = rect.height + "px";
  resizeCanvas();
  const h = rect.height;
  GAME.groundY = h * GAME.groundRatio;
  player.y = GAME.groundY - player.h;
}
window.addEventListener('resize', initCanvasSize);
initCanvasSize();

/* UI */
const titleOverlay = document.getElementById('titleOverlay');
const titleStartBtn = document.getElementById('titleStartBtn');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayMsg = document.getElementById('overlayMsg');
const retryBtn = document.getElementById('retryBtn');
const backTitleBtn = document.getElementById('backTitleBtn');
const modeLabel = document.getElementById('modeLabel');
const difficultyLabel = document.getElementById('difficultyLabel');
const timeLabel = document.getElementById('timeLabel');
const livesLabel = document.getElementById('livesLabel');
const bestLabel = document.getElementById('bestLabel');

/* モード・難易度 */
let mode = 'ta';
let difficulty = 'normal';
document.querySelectorAll('input[name="mode"]').forEach(r=>{
  r.addEventListener('change', e=>{
    mode = e.target.value;
    modeLabel.textContent = mode === 'ta' ? 'TA' : 'Life';
    updateHudVisibility();
  });
});
document.querySelectorAll('input[name="difficulty"]').forEach(r=>{
  r.addEventListener('change', e=>{
    difficulty = e.target.value;
    difficultyLabel.textContent = diffLabel(difficulty);
  });
});
function diffLabel(d){
  if(d === 'normal') return 'Normal';
  if(d === 'hard') return 'Hard';
  return 'Very Hard';
}
function updateHudVisibility(){
  if(mode === 'ta'){
    livesLabel.style.display = 'none';
    bestLabel.style.display = '';
  } else {
    livesLabel.style.display = '';
    bestLabel.style.display = 'none';
  }
}
updateHudVisibility();

/* 状態 */
let running = false;
let lastTime = 0;
let elapsedSinceStart = 0;
let mapOffset = 0;
let mapData = null;
let lives = 3;
let fallStartY = null;

let bestTimeKeyBase = 'packet-runner-best-time-vertical-';
function bestKeyForDifficulty(){ return bestTimeKeyBase + difficulty; }
let taBest = null;

let invulnerableTimer = 0;
let flashT = 0;

/* 難易度パラメータ */
const DIFFICULTY_CONFIG = {
  normal: {
    blockChance: 0.22,
    blockMinH: 24,
    blockMaxH: 55,
    gapChance: 0.18,
    gapMin: 60,
    gapMax: 160,
    baseLength: 2600,
  },
  hard: {
    blockChance: 0.30,
    blockMinH: 30,
    blockMaxH: 80,
    gapChance: 0.22,
    gapMin: 70,
    gapMax: 180,
    baseLength: 3100,
  },
  veryhard: {
    blockChance: 0.40,
    blockMinH: 40,
    blockMaxH: 110,
    gapChance: 0.26,
    gapMin: 80,
    gapMax: 200,
    baseLength: 3600,
  }
};
function getCurrentDiffConfig(){
  return DIFFICULTY_CONFIG[difficulty] || DIFFICULTY_CONFIG.normal;
}

/* マップ生成（物理的に飛べるギャップだけ） */
function generateMap(){
  const cfg = getCurrentDiffConfig();
  const totalLength = cfg.baseLength + Math.floor(Math.random()*800);
  const segs = [];
  let x = 0;
  const minRun = 140;
  const MAX_GAP_WIDTH = 200; // これ以上は絶対出さない

  while(x < totalLength){
    const r = Math.random();

    if(r < cfg.gapChance && x > 200){
      const gapMin = Math.min(cfg.gapMin, MAX_GAP_WIDTH * 0.6);
      const gapMax = Math.min(cfg.gapMax, MAX_GAP_WIDTH);
      const gapW = randInt(gapMin, gapMax);

      segs.push({type:'gap', x, width:gapW});
      x += gapW;

      // 着地用の足場
      const safeRunMin = 140;
      const safeRunMax = 220;
      const run = randInt(safeRunMin, safeRunMax);
      segs.push({type:'ground', x, width:run});
      x += run;

    } else {
      const run = randInt(minRun, minRun+220);
      const groundStart = x;
      segs.push({type:'ground', x:groundStart, width:run});
      x += run;

      const canPlaceBlock = run > 120;
      if(canPlaceBlock && Math.random() < cfg.blockChance && groundStart > 180){
        const blockW = randInt(26,50);
        const blockH = randInt(cfg.blockMinH, cfg.blockMaxH);
        const margin = 40;
        const maxOffset = Math.max(margin+blockW, run - margin - blockW);
        const offset = randInt(margin, maxOffset);
        segs.push({
          type:'block',
          x: groundStart + offset,
          width:blockW,
          height:blockH
        });
      }
    }
  }
  segs.push({type:'goal', x: totalLength+40, width: 40});
  return {totalLength, segments:segs};
}
function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

/* 入力 */
function doJump(){
  if(!running) return;
  if(player.onGround){
    player.vy = GAME.jumpImpulse;
    player.onGround = false;
  }
}
window.addEventListener('keydown', e=>{
  if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); doJump(); }
});
canvas.addEventListener('mousedown', ()=>{ doJump(); });
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); doJump(); }, {passive:false});

/* スタート・リセット */
titleStartBtn.addEventListener('click', ()=>{
  modeLabel.textContent = mode === 'ta' ? 'TA' : 'Life';
  difficultyLabel.textContent = diffLabel(difficulty);
  startGame();
});
retryBtn.addEventListener('click', ()=>{ startGame(); });
backTitleBtn.addEventListener('click', ()=>{ backToTitle(); });

function startGame(){
  titleOverlay.classList.remove('visible');
  hideOverlay();
  resetGame();
  running = true;
  lastTime = performance.now();
  const key = bestKeyForDifficulty();
  taBest = localStorage.getItem(key) ? parseFloat(localStorage.getItem(key)) : null;
  bestLabel.textContent = taBest ? 'Best: ' + taBest.toFixed(2) + 's' : 'Best: —';
  requestAnimationFrame(loop);
}
function backToTitle(){
  running = false;
  titleOverlay.classList.add('visible');
  hideOverlay();
  resetGame();
}
function resetGame(){
  running = false;
  lastTime = 0;
  elapsedSinceStart = 0;
  mapOffset = 0;
  mapData = generateMap();
  lives = 3;
  fallStartY = null;
  player.y = GAME.groundY - player.h;
  player.vy = 0;
  player.onGround = true;
  timeLabel.textContent = 'Time: 0.00s';
  livesLabel.textContent = 'Lives: ' + lives;
}

/* ループ */
function loop(ts){
  if(!running){
    render();
    return;
  }
  const dt = Math.min(0.05, (ts - lastTime)/1000);
  lastTime = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
function update(dt){
  elapsedSinceStart += dt;

  player.vy += GAME.gravity * dt;
  player.y += player.vy * dt;

  const worldX = mapOffset + player.x + player.w/2;
  const onGroundNow = isGroundAt(worldX);

  if(onGroundNow){
    if(player.y + player.h >= GAME.groundY){
      player.y = GAME.groundY - player.h;
      player.vy = 0;
      player.onGround = true;
      fallStartY = null;
    }
  } else {
    if(player.onGround){
      fallStartY = player.y;
    }
    player.onGround = false;
  }

  // 隙間に一定距離落ちたらゲームオーバー
  if(fallStartY !== null && player.y - fallStartY > 80){
    handleHit(true);
    return;
  }

  mapOffset += GAME.scrollSpeed * dt;

  timeLabel.textContent = 'Time: ' + elapsedSinceStart.toFixed(2) + 's';
  livesLabel.textContent = 'Lives: ' + lives;

  const blocks = mapData.segments.filter(s=>s.type==='block');
  for(const b of blocks){
    const bx = b.x - mapOffset;
    const by = GAME.groundY - b.height;
    if(rectsOverlap(player.x, player.y, player.w, player.h, bx, by, b.width, b.height)){
      handleHit();
      return;
    }
  }

  const canvasHeight = canvas.clientHeight;
  if(player.y > canvasHeight + 40){
    handleHit(true);
    return;
  }

  const goalSeg = mapData.segments.find(s=>s.type==='goal');
  if(goalSeg){
    const gx = goalSeg.x - mapOffset;
    if(gx + goalSeg.width < player.x + player.w){
      handleVictory();
      return;
    }
  }

  if(invulnerableTimer > 0) invulnerableTimer = Math.max(0, invulnerableTimer - dt);
  if(flashT > 0) flashT = Math.max(0, flashT - dt);
}
function isGroundAt(worldX){
  for(const s of mapData.segments){
    if(s.type === 'gap'){
      if(worldX >= s.x && worldX < s.x + s.width) return false;
    }
  }
  return true;
}
function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

/* ヒット・勝利 */
function handleHit(){
  if(invulnerableTimer > 0) return;
  invulnerableTimer = 0.8;
  flashT = 0.25;

  if(mode === 'ta'){
    running = false;
    showOverlay("GAME OVER","障害にぶつかってしまった…\nTAは失敗です。\nもう一度挑戦しますか？");
  } else {
    lives -= 1;
    livesLabel.textContent = 'Lives: ' + lives;
    if(lives <= 0){
      running = false;
      showOverlay("GAME OVER","ライフがなくなってしまった…\nもう一度挑戦しますか？");
    } else {
      player.y = GAME.groundY - player.h;
      player.vy = 0;
      player.onGround = true;
      mapOffset = Math.max(0, mapOffset - 180);
    }
  }
}
function handleVictory(){
  running = false;
  if(mode === 'ta'){
    const t = elapsedSinceStart;
    const key = bestKeyForDifficulty();
    const prev = localStorage.getItem(key) ? parseFloat(localStorage.getItem(key)) : null;
    let msg;
    if(prev === null || t < prev){
      localStorage.setItem(key, String(t));
      taBest = t;
      bestLabel.textContent = 'Best: ' + taBest.toFixed(2) + 's';
      msg = `GOAL！\nNew Best: ${t.toFixed(2)}s`;
    } else {
      msg = `GOAL！\nTime: ${t.toFixed(2)}s`;
    }
    showOverlay("GOAL", msg + "\nもう一度挑戦しますか？");
  } else {
    showOverlay("GOAL","ゴールに到達しました！\nもう一度挑戦しますか？");
  }
}

/* オーバーレイ */
function showOverlay(title, msg){
  overlayTitle.textContent = title;
  overlayMsg.textContent = msg;
  overlay.classList.add('visible');
}
function hideOverlay(){
  overlay.classList.remove('visible');
}

/* 描画 */
function render(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);

  ctx.fillStyle = "#020617";
  ctx.fillRect(0,0,w,h);

  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground').trim();
  ctx.strokeStyle = getComputedStyle(document.documentElement)
    .getPropertyValue('--ground-top')
    .trim();
  ctx.fillRect(0,GAME.groundY,w,h-GAME.groundY);

  for(const s of mapData.segments){
    const x = s.x - mapOffset;
    if(x + s.width < -100 || x > w+100) continue;
    if(s.type === 'gap'){
      ctx.fillStyle = "#020617";
      ctx.fillRect(x,GAME.groundY,s.width,h-GAME.groundY);
    } else if(s.type === 'block'){
      const by = GAME.groundY - s.height;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--obstacle').trim();
      ctx.fillRect(x,by,s.width,s.height);
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(x,by,s.width,s.height*0.2);
    } else if(s.type === 'goal'){
      const gx = x;
      const gy = GAME.groundY - 100;
      ctx.fillStyle = "#facc15";
      ctx.fillRect(gx+8,gy,6,90);
      ctx.fillStyle = "#e11d48";
      ctx.beginPath();
      ctx.moveTo(gx+14,gy+12);
      ctx.lineTo(gx+42,gy+32);
      ctx.lineTo(gx+14,gy+50);
      ctx.closePath();
      ctx.fill();
    }
  }

  ctx.save();
  if(invulnerableTimer > 0){
    if(Math.floor(performance.now()/80)%2===0) ctx.globalAlpha = 0.4;
  }
  ctx.fillStyle = player.color || "#60a5fa";
  roundRect(ctx, player.x, player.y, player.w, player.h, 8, true, false);
  ctx.restore();

  ctx.fillStyle = "#e5e7eb";
  ctx.font = "13px system-ui";
  ctx.fillText("Time: " + elapsedSinceStart.toFixed(2) + "s", 8, 18);
  if(mode === 'life'){
    ctx.fillText("Lives: " + lives, 8, 36);
  } else if(taBest){
    ctx.fillText("Best: " + taBest.toFixed(2) + "s", 8, 36);
  }

  if(flashT > 0){
    ctx.fillStyle = `rgba(248,113,113,${flashT*2})`;
    ctx.fillRect(0,0,w,h);
  }
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if(typeof r === 'number') r={tl:r,tr:r,br:r,bl:r};
  ctx.beginPath();
  ctx.moveTo(x+r.tl,y);
  ctx.lineTo(x+w-r.tr,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r.tr);
  ctx.lineTo(x+w,y+h-r.br);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h);
  ctx.lineTo(x+r.bl,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r.bl);
  ctx.lineTo(x,y+r.tl);
  ctx.quadraticCurveTo(x,y,x+r.tl,y);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* 初期 */
mapData = generateMap();
player.y = GAME.groundY - player.h;
player.onGround = true;
render();
console.log("Packet Runner fixed build loaded.");
</script>
</body>
</html>
